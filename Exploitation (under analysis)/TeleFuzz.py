######################################################################################################################################################################################################################
# Python script Penetration Testing & Ethical Hacking telecom protocols.!!!!Under Analysis!!! 
# sudo python3 pt_framework.py. Optional API's, and subdomain bruteforce. 
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software 
# without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons 
# to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial 
# portions of the Software.
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE 
# AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
######################################################################################################################################################################################################################

import socket
import random
import subprocess
import os
from time import sleep
import json

# Banner
def display_splash_screen():
    splash = r"""
  
    
______________________.____    __________________________ _______________________              _____  ____.____   __________  ___ ___    _____           _______  ____ 
\__    ___/\_   _____/|    |   \_   _____/\_   _____/    |   \____    /\____    /             /  |  |/_   |    |  \______   \/   |   \  /  |  |          \   _  \/_   |
  |    |    |    __)_ |    |    |    __)_  |    __) |    |   / /     /   /     /    ______   /   |  |_|   |    |   |     ___/    ~    \/   |  |_  ______ /  /_\  \|   |
  |    |    |        \|    |___ |        \ |     \  |    |  / /     /_  /     /_   /_____/  /    ^   /|   |    |___|    |   \    Y    /    ^   / /_____/ \  \_/   \   |
  |____|   /_______  /|_______ |_______  / \___  /  |______/ /_______ \/_______ \           \____   | |___|_______ \____|    \___|_  /\____   |           \_____  /___|
                   \/         \/       \/      \/                    \/        \/                |__|             \/               \/      |__|                 \/     

                                                     _:_
                                                    '-.-'
                                           ()      __.'.__
                                        .-:--:-.  |_______|
                                 ()      \____/    \=====/
                                 /\      {====}     )___(
                      (\=,      //\\      )__(     /_____\
      __    |'-'-'|  //  .\    (    )    /____\     |   |
     /  \   |_____| (( \_  \    )__(      |  |      |   |
     \__/    |===|   ))  `\_)  /____\     |  |      |   |
    /____\   |   |  (/     \    |  |      |  |      |   |
     |  |    |   |   | _.-'|    |  |      |  |      |   |
     |__|    )___(    )___(    /____\    /____\    /_____\
    (====)  (=====)  (=====)  (======)  (======)  (=======)
    }===={  }====={  }====={  }======{  }======{  }======={
   (______)(_______)(_______)(________)(________)(_________)
   
 
"""

    print(splash)
    print("Telecoms Fuzzer GTP, SIP, NGAP, HTTP/2, Diameter, SCTP, TCP, UDP 41PH4-01\n")

class Fuzzer:
    def __init__(self, protocol, target_ip, target_port, fuzz_mode):
        """
        Initialize the Fuzzer.
        
        :param protocol: Protocol to test (e.g., GTP, SIP, NGAP).
        :param target_ip: IP address of the target.
        :param target_port: Port of the target service.
        :param fuzz_mode: Mode of fuzzing ('generation' or 'mutation').
        """
        self.protocol = protocol
        self.target_ip = target_ip
        self.target_port = target_port
        self.fuzz_mode = fuzz_mode
        self.exploit_payload = None
        self.fuzzing_data = []
        self.analysis_results = []
        self.vulnerabilities = {
            'Critical': [],
            'High': [],
            'Medium': [],
            'Low': []
        }

    def generate_fuzz_data(self):
        """Generate fuzzing test cases based on the fuzz mode."""
        print(f"Generating fuzz data using {self.fuzz_mode} mode for protocol {self.protocol}...")
        if self.fuzz_mode == "generation":
            self.fuzzing_data = [self._generate_case(i) for i in range(100)]
        elif self.fuzz_mode == "mutation":
            self.fuzzing_data = [self._mutate_case(i) for i in range(100)]
        self.save_results("fuzzing_data", self.fuzzing_data)
    
    def _generate_case(self, index):
        """Generate a fuzzing payload for testing buffer overflows."""
        return "A" * (64 + index)  # Simulate increasing payload length
    
    def _mutate_case(self, index):
        """Generate a mutated fuzzing payload."""
        return "B" * (64 + random.randint(1, 10))  # Mutated fuzz case with random variation
    
    def send_fuzz_data(self):
        """Send fuzz data to the target protocol service."""
        for data in self.fuzzing_data:
            self._send_payload(data)
    
    def _send_payload(self, payload):
        """Send the fuzzing payload to the target system."""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.target_ip, self.target_port))
            s.send(payload.encode())
            s.close()
            print(f"Sent fuzz payload to {self.target_ip}:{self.target_port}")
        except Exception as e:
            print(f"Error sending payload: {e}")
    
    def analyze_crash(self, crash_data):
        """Analyse crash data for vulnerability identification."""
        print("Analysing crash...")
        
        # Placeholder for crash detection logic
        if "buffer overflow" in crash_data:
            vulnerability = "buffer_overflow_vulnerability"
            severity = "Critical"
        elif "format string" in crash_data:
            vulnerability = "format_string_vulnerability"
            severity = "High"
        else:
            vulnerability = "unknown_vulnerability"
            severity = "Medium"
        
        return vulnerability, severity
    
    def chain_vulnerabilities(self):
        """Simulate chaining of vulnerabilities."""
        if "Critical" in self.vulnerabilities and "High" in self.vulnerabilities:
            print("Attempting to chain Critical and High vulnerabilities...")
            return "Chained Critical + High vulnerability exploit"
        else:
            return "No chaining possible with current vulnerabilities."

    def generate_report(self, vulnerability_type, severity, vulnerability_details):
        """Generate a detailed report for the detected vulnerability."""
        print(f"Report: Vulnerability Detected - {vulnerability_type} ({severity})")
        report = {
            "vulnerability": vulnerability_type,
            "severity": severity,
            "details": vulnerability_details,
            "suggested_fixes": "Apply proper input validation.",
            "exploitation": "No exploitation attempted to avoid downtime."
        }
        self.save_results("analysis_report", report)
    
    def generate_exploit_poc(self):
        """Generate a proof of concept (PoC) for the identified vulnerability."""
        self.exploit_payload = "Exploit PoC: NOP sled + Shellcode"
        print(f"PoC Exploit Generated: {self.exploit_payload}")
        return self.exploit_payload

    def save_results(self, result_type, data):
        """Save results to a JSON file for later analysis."""
        if not os.path.exists('results'):
            os.mkdir('results')
        result_file = f"results/{result_type}.json"
        with open(result_file, 'w') as f:
            json.dump(data, f, indent=4)
        print(f"Results saved to {result_file}")

    def record_vulnerability(self, vulnerability, severity):
        """Record a detected vulnerability into the severity-based categories."""
        if severity == "Critical":
            self.vulnerabilities['Critical'].append(vulnerability)
        elif severity == "High":
            self.vulnerabilities['High'].append(vulnerability)
        elif severity == "Medium":
            self.vulnerabilities['Medium'].append(vulnerability)
        elif severity == "Low":
            self.vulnerabilities['Low'].append(vulnerability)


class PacketCapture:
    """Class to monitor and capture network traffic."""
    def __init__(self, interface="eth0"):
        self.interface = interface
    
    def start_capture(self):
        """Start packet capture using tcpdump."""
        print(f"Starting packet capture on {self.interface}...")
        subprocess.run(["tcpdump", "-i", self.interface, "-w", "capture.pcap"])


def user_input_prompt():
    """Prompt the user for various inputs to customize fuzzing."""
    print("\n--- Select a Protocol to Test ---")
    protocols = ["GTP", "SIP", "NGAP", "HTTP/2", "Diameter", "SCTP", "TCP", "UDP"]
    for idx, protocol in enumerate(protocols, 1):
        print(f"{idx}. {protocol}")
    
    protocol_choice = int(input("Enter the number corresponding to the protocol: "))
    protocol = protocols[protocol_choice - 1]
    
    target_ip = input("Enter the target IP address: ")
    target_port = int(input("Enter the target port: "))
    
    print("\n--- Select Fuzzing Mode ---")
    fuzz_modes = ["generation", "mutation"]
    for idx, mode in enumerate(fuzz_modes, 1):
        print(f"{idx}. {mode}")
    
    fuzz_mode_choice = int(input("Enter the number corresponding to the fuzzing mode: "))
    fuzz_mode = fuzz_modes[fuzz_mode_choice - 1]
    
    return protocol, target_ip, target_port, fuzz_mode


def main():
    """Main function to execute fuzzing and vulnerability detection."""
    print("Welcome to the Protocol Fuzzing and Vulnerability Detection System!\n")
    
    # Get user input for protocol selection and fuzzing setup
    protocol, target_ip, target_port, fuzz_mode = user_input_prompt()
    
    # Initialize fuzzer and packet capture
    fuzzer = Fuzzer(protocol, target_ip, target_port, fuzz_mode)
    packet_capture = PacketCapture()

    # Option to start packet capture
    capture_choice = input("Do you want to start packet capture? (y/n): ").lower()
    if capture_choice == 'y':
        packet_capture.start_capture()
    
    # Generate fuzzing data and send it
    fuzzer.generate_fuzz_data()
    fuzzer.send_fuzz_data()
    
    # Simulate crash detection and analysis
    crash_data = "buffer overflow crash detected"  # Simulating crash data
    vulnerability_type, severity = fuzzer.analyze_crash(crash_data)
    
    # Record vulnerability
    fuzzer.record_vulnerability(vulnerability_type, severity)
    
    # Generate report if a vulnerability is found
    if severity == "Critical" or severity == "High":
        fuzzer.generate_report(vulnerability_type, severity, crash_data)
        fuzzer.generate_exploit_poc()

        # Chain vulnerabilities if possible
        chain_result = fuzzer.chain_vulnerabilities()
        print(f"Vulnerability Chain Result: {chain_result}")
    
    print("\n--- Fuzzing and vulnerability detection completed ---\n")
    print("Results saved for later analysis.")
    

if __name__ == "__main__":
    main()

