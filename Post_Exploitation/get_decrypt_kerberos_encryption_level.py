#######################################################################################################################################################################
# Python script that acquires the Kerberos encryption type, note requires installation of ldap3 #pip install ldap3. Gleaned credentials required for authentication.
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the       
# Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, # and to permit persons to whom the Software is furnished to do
# so, subject to the following conditions: The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A  
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
########################################################################################################################################################################

import ldap3
from ldap3 import Server, Connection, ALL, NTLM
from ldap3.core.exceptions import LDAPBindError

# Banner
def display_splash_screen():
    splash = """
   def display_splash_screen():
    splash = """
    
 ____  __.            ___.                                .____                         .__                 _____  ____.____   __________  ___ ___    _____           _______  ____ 
|    |/ _|____ _______\_ |__   ____ _______  ____  ______ |    |     _______  __  ____  |  |               /  |  |/_   |    |  \______   \/   |   \  /  |  |          \   _  \/_   |
|      <_/ __ \\_  __ \| __ \_/ __ \\_  __ \/  _ \/  ___/ |    |   _/ __ \  \/ /_/ __ \ |  |     ______   /   |  |_|   |    |   |     ___/    ~    \/   |  |_  ______ /  /_\  \|   |
|    |  \  ___/ |  | \/| \_\ \  ___/ |  | \(  <_> )___ \  |    |___\  ___/\   / \  ___/ |  |__  /_____/  /    ^   /|   |    |___|    |   \    Y    /    ^   / /_____/ \  \_/   \   |
|____|__ \___  >|__|   |___  /\___  >|__|   \____/____  > |_______ \\___  >\_/   \___  >|____/           \____   | |___|_______ \____|    \___|_  /\____   |           \_____  /___|
        \/   \/            \/     \/                  \/          \/    \/           \/                       |__|             \/               \/      |__|                 \/     

                                                     _:_
                                                    '-.-'
                                           ()      __.'.__
                                        .-:--:-.  |_______|
                                 ()      \____/    \=====/
                                 /\      {====}     )___(
                      (\=,      //\\      )__(     /_____\
      __    |'-'-'|  //  .\    (    )    /____\     |   |
     /  \   |_____| (( \_  \    )__(      |  |      |   |
     \__/    |===|   ))  `\_)  /____\     |  |      |   |
    /____\   |   |  (/     \    |  |      |  |      |   |
     |  |    |   |   | _.-'|    |  |      |  |      |   |
     |__|    )___(    )___(    /____\    /____\    /_____\
    (====)  (=====)  (=====)  (======)  (======)  (=======)
    }===={  }====={  }====={  }======{  }======{  }======={
   (______)(_______)(_______)(________)(________)(_________)
   
 
"""

    print(splash)
    print("Kerberos Level 41PH4-01\n")

# Function to decode the msDS-SupportedEncryptionTypes attribute
def decode_encryption_types(supported_encryption_types):
    types = []
    if supported_encryption_types & 0x01:
        types.append("DES-CBC-CRC")
    if supported_encryption_types & 0x02:
        types.append("DES-CBC-MD5")
    if supported_encryption_types & 0x04:
        types.append("RC4-HMAC")
    if supported_encryption_types & 0x08:
        types.append("AES128-CTS-HMAC-SHA1-96")
    if supported_encryption_types & 0x10:
        types.append("AES256-CTS-HMAC-SHA1-96")
    if supported_encryption_types & 0x20:
        types.append("Future encryption type")
    return ", ".join(types)

# Replace these with your actual domain and user credentials
domain = 'your_domain'
username = 'your_username'
password = 'your_password'
dc_ip = 'your_dc_ip'  # IP address of a domain controller

# Connect to the domain controller
server = Server(dc_ip, get_info=ALL)
conn = Connection(server, user=f'{domain}\\{username}', password=password, authentication=NTLM)

try:
    if not conn.bind():
        raise LDAPBindError(f"Failed to bind to server: {conn.result}")
    
    # Search for all domain controllers
    conn.search(search_base='CN=Configuration,DC=your,DC=domain', 
                search_filter='(objectClass=computer)', 
                attributes=['dNSHostName', 'msDS-SupportedEncryptionTypes'])
    
    results = []
    for entry in conn.entries:
        hostname = entry.dNSHostName.value
        supported_encryption_types = entry.msDS-SupportedEncryptionTypes.value if entry.msDS-SupportedEncryptionTypes.value is not None else 0
        decoded_types = decode_encryption_types(supported_encryption_types)
        results.append({
            "DomainController": hostname,
            "SupportedEncryptionTypes": supported_encryption_types,
            "Explanation": decoded_types if decoded_types else "Not Set"
        })
    
    # Output the results
    for result in results:
        print(f"Domain Controller: {result['DomainController']}")
        print(f"Supported Encryption Types: {result['SupportedEncryptionTypes']}")
        print(f"Explanation: {result['Explanation']}\n")

except LDAPBindError as e:
    print(e)

finally:
    conn.unbind()
