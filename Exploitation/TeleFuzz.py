#####################################################################################################################################################################
# Python script to fuzz telecommunication protocols.
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the       
# Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, # and to permit persons to whom the Software is furnished to do
# so, subject to the following conditions: The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A  
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#####################################################################################################################################################################

import socket
import random
import subprocess
import os
from time import sleep
import json

# Banner
def display_splash_screen():
    splash = r"""

______________________.____    __________________________ _______________________              _____  ____.____   __________  ___ ___    _____           _______  ____ 
\__    ___/\_   _____/|    |   \_   _____/\_   _____/    |   \____    /\____    /             /  |  |/_   |    |  \______   \/   |   \  /  |  |          \   _  \/_   |
  |    |    |    __)_ |    |    |    __)_  |    __) |    |   / /     /   /     /    ______   /   |  |_|   |    |   |     ___/    ~    \/   |  |_  ______ /  /_\\  \|   |
  |    |    |        \|    |___ |        \ |     \  |    |  / /     /_  /     /_   /_____/  /    ^   /|   |    |___|    |   \    Y    /    ^   / /_____/ \  \_/   \   |
  |____|   /_______  /|_______ |_______  / \___  /  |______/ /_______ \/_______ \           \____   | |___|_______ \____|    \___|_  /\____   |           \_____  /___|
                   \/         \/       \/      \/                    \/        \/                |__|             \/               \/      |__|                 \/     

                                                     _:_
                                                    '-.-'
                                           ()      __.'.__
                                        .-:--:-.  |_______|
                                 ()      \____/    \=====/
                                 /\\     {====}     )___(
                      (\=,      //\\      )__(     /_____\\
      __    |'-'-'|  //  .\    (    )    /____\     |   |
     /  \   |_____| (( \_  \    )__(      |  |      |   |
     \__/    |===|   ))  `\_)  /____\     |  |      |   |
    /____\   |   |  (/     \    |  |      |  |      |   |
     |  |    |   |   | _.-'|    |  |      |  |      |   |
     |__|    )___(    )___(    /____\    /____\    /_____\\
    (====)  (=====)  (=====)  (======)  (======)  (=======)
    }===={  }====={  }====={  }======{  }======{  }======={
   (______)(_______)(_______)(________)(________)(_________)
   
 
"""
    print(splash)
    print("Telecoms Fuzzer for GTP, SIP, NGAP, HTTP/2, Diameter, SCTP, TCP, UDP 41PH4-01\n")

class Fuzzer:
    def __init__(self, protocol, target_ip, target_port, fuzz_mode):
        self.protocol = protocol
        self.target_ip = target_ip
        self.target_port = target_port
        self.fuzz_mode = fuzz_mode
        self.exploit_payload = None
        self.fuzzing_data = []
        self.analysis_results = []
        self.vulnerabilities = {
            'Critical': [],
            'High': [],
            'Medium': [],
            'Low': []
        }

    def generate_fuzz_data(self):
        print(f"Generating fuzz data using {self.fuzz_mode} mode for protocol {self.protocol}...")
        if self.fuzz_mode == "generation":
            self.fuzzing_data = [self._generate_case(i) for i in range(100)]
        elif self.fuzz_mode == "mutation":
            self.fuzzing_data = [self._mutate_case(i) for i in range(100)]
        self.save_results("fuzzing_data", self.fuzzing_data)
    
    def _generate_case(self, index):
        return "A" * (64 + index)  # Simulate increasing payload length
    
    def _mutate_case(self, index):
        return "B" * (64 + random.randint(1, 10))  # Mutated fuzz case with random variation
    
    def send_fuzz_data(self):
        for data in self.fuzzing_data:
            self._send_payload(data)
    
    def _send_payload(self, payload):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((self.target_ip, self.target_port))
            s.send(payload.encode())
            s.close()
            print(f"Sent fuzz payload to {self.target_ip}:{self.target_port}")
        except Exception as e:
            print(f"Error sending payload: {e}")
    
    def analyze_crash(self, crash_data):
        print("Analysing crash...")
        if "buffer overflow" in crash_data:
            vulnerability = "buffer_overflow_vulnerability"
            severity = "Critical"
        elif "format string" in crash_data:
            vulnerability = "format_string_vulnerability"
            severity = "High"
        else:
            vulnerability = "unknown_vulnerability"
            severity = "Medium"
        return vulnerability, severity

    def generate_report(self, vulnerability_type, severity, vulnerability_details):
        print(f"Report: Vulnerability Detected - {vulnerability_type} ({severity})")
        report = {
            "vulnerability": vulnerability_type,
            "severity": severity,
            "details": vulnerability_details,
            "suggested_fixes": "Apply proper input validation.",
            "exploitation": "No exploitation attempted to avoid downtime."
        }
        self.save_results("analysis_report", report)

    def generate_exploit_poc(self):
        self.exploit_payload = "Exploit PoC: NOP sled + Shellcode"
        print(f"PoC Exploit Generated: {self.exploit_payload}")
        return self.exploit_payload

    def save_results(self, result_type, data):
        if not os.path.exists('results'):
            os.mkdir('results')
        result_file = f"results/{result_type}.json"
        with open(result_file, 'w') as f:
            json.dump(data, f, indent=4)
        print(f"Results saved to {result_file}")

class PacketCapture:
    def __init__(self, interface="eth0"):
        self.interface = interface
    
    def start_capture(self):
        print(f"Starting packet capture on {self.interface}...")
        subprocess.run(["tcpdump", "-i", self.interface, "-w", "capture.pcap"])

def main_menu():
    while True:
        print("\n--- Main Menu ---")
        print("1. Perform Fuzzing")
        print("2. Start Packet Capture")
        print("3. Generate Exploit POC")
        print("4. Exit")

        choice = input("Enter your choice: ")

        if choice == "1":
            perform_fuzzing()
        elif choice == "2":
            start_packet_capture()
        elif choice == "3":
            generate_poc()
        elif choice == "4":
            print("Exiting...\n")
            break
        else:
            print("Invalid choice. Please try again.")

def perform_fuzzing():
    protocol, target_ip, target_port, fuzz_mode = user_input_prompt()
    fuzzer = Fuzzer(protocol, target_ip, target_port, fuzz_mode)
    fuzzer.generate_fuzz_data()
    fuzzer.send_fuzz_data()
    crash_data = "buffer overflow crash detected"
    vulnerability_type, severity = fuzzer.analyze_crash(crash_data)
    fuzzer.generate_report(vulnerability_type, severity, crash_data)

def start_packet_capture():
    interface = input("Enter the network interface for packet capture: ")
    packet_capture = PacketCapture(interface)
    packet_capture.start_capture()

def generate_poc():
    print("Generating POC...")
    fuzzer = Fuzzer("Sample Protocol", "127.0.0.1", 80, "generation")
    poc = fuzzer.generate_exploit_poc()
    print(f"Generated POC: {poc}")

def user_input_prompt():
    print("\n--- Select a Protocol to Test ---")
    protocols = ["GTP", "SIP", "NGAP", "HTTP/2", "Diameter", "SCTP", "TCP", "UDP"]
    for idx, protocol in enumerate(protocols, 1):
        print(f"{idx}. {protocol}")
    protocol_choice = int(input("Enter the number corresponding to the protocol: "))
    protocol = protocols[protocol_choice - 1]

    target_ip = input("Enter the target IP address: ")
    target_port = int(input("Enter the target port: "))

    print("\n--- Select Fuzzing Mode ---")
    fuzz_modes = ["generation", "mutation"]
    for idx, mode in enumerate(fuzz_modes, 1):
        print(f"{idx}. {mode}")
    fuzz_mode_choice = int(input("Enter the number corresponding to the fuzzing mode: "))
    fuzz_mode = fuzz_modes[fuzz_mode_choice - 1]

    return protocol, target_ip, target_port, fuzz_mode

if __name__ == "__main__":
    display_splash_screen()
    main_menu()
